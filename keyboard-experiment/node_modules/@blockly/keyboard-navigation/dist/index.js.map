{"version":3,"file":"index.js","mappings":"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","sources":["webpack://@blockly/keyboard-navigation/webpack/universalModuleDefinition","webpack://@blockly/keyboard-navigation/external umd {\"root\":\"Blockly\",\"commonjs\":\"blockly/core\",\"commonjs2\":\"blockly/core\",\"amd\":\"blockly/core\"}","webpack://@blockly/keyboard-navigation/webpack/bootstrap","webpack://@blockly/keyboard-navigation/webpack/runtime/define property getters","webpack://@blockly/keyboard-navigation/webpack/runtime/hasOwnProperty shorthand","webpack://@blockly/keyboard-navigation/webpack/runtime/make namespace object","webpack://@blockly/keyboard-navigation/./src/constants.js","webpack://@blockly/keyboard-navigation/./src/flyout_cursor.js","webpack://@blockly/keyboard-navigation/./src/line_cursor.js","webpack://@blockly/keyboard-navigation/./src/navigation.js","webpack://@blockly/keyboard-navigation/./src/gesture_monkey_patch.js","webpack://@blockly/keyboard-navigation/./src/navigation_controller.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"blockly/core\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"blockly/core\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"blockly/core\")) : factory(root[\"Blockly\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, (__WEBPACK_EXTERNAL_MODULE__573__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__573__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Constants for keyboard navigation.\n * @author aschmiedt@google.com (Abby Schmiedt)\n */\n\n/**\n * Keyboard navigation states.\n * The different parts of Blockly that the user navigates between.\n * @enum {string}\n * @const\n * @public\n */\nexport const STATE = {\n  WORKSPACE: 'workspace',\n  FLYOUT: 'flyout',\n  TOOLBOX: 'toolbox',\n};\n\n/**\n * Default keyboard navigation shortcut names.\n * @enum {string}\n * @const\n * @public\n */\nexport const SHORTCUT_NAMES = {\n  PREVIOUS: 'previous',\n  NEXT: 'next',\n  IN: 'in',\n  OUT: 'out',\n  INSERT: 'insert',\n  MARK: 'mark',\n  DISCONNECT: 'disconnect',\n  TOOLBOX: 'toolbox',\n  EXIT: 'exit',\n  TOGGLE_KEYBOARD_NAV: 'toggle_keyboard_nav',\n  COPY: 'keyboard_nav_copy',\n  CUT: 'keyboard_nav_cut',\n  PASTE: 'keyboard_nav_paste',\n  DELETE: 'keyboard_nav_delete',\n  MOVE_WS_CURSOR_UP: 'workspace_up',\n  MOVE_WS_CURSOR_DOWN: 'workspace_down',\n  MOVE_WS_CURSOR_LEFT: 'workspace_left',\n  MOVE_WS_CURSOR_RIGHT: 'workspace_right',\n};\n\n/**\n * Types of possible messages passed into the loggingCallback in the Navigation\n * class.\n * @enum {string}\n * @const\n * @public\n */\nexport const LOGGING_MSG_TYPE = {\n  ERROR: 'error',\n  WARN: 'warn',\n  LOG: 'log',\n};\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The class representing a cursor used to navigate the flyout.\n * @author aschmiedt@google.com (Abby Schmiedt)\n */\n\nimport * as Blockly from 'blockly/core';\n\n/**\n * Class for a flyout cursor.\n * This controls how a user navigates blocks in the flyout.\n * This cursor only allows a user to go to the previous or next stack.\n * @constructor\n * @extends {Blockly.Cursor}\n */\nexport class FlyoutCursor extends Blockly.Cursor {\n  /**\n   * The constructor for the FlyoutCursor.\n   */\n  constructor() {\n    super();\n  }\n\n  /**\n   * Moves the cursor to the next stack of blocks in the flyout.\n   * @returns {Blockly.ASTNode} The next element, or null if the current node is\n   *     not set or there is no next value.\n   * @override\n   */\n  next() {\n    const curNode = this.getCurNode();\n    if (!curNode) {\n      return null;\n    }\n    const newNode = curNode.next();\n\n    if (newNode) {\n      this.setCurNode(newNode);\n    }\n    return newNode;\n  }\n\n  /**\n   * This is a no-op since a flyout cursor can not go in.\n   * @returns {null} Always null.\n   * @override\n   */\n  in() {\n    return null;\n  }\n\n  /**\n   * Moves the cursor to the previous stack of blocks in the flyout.\n   * @returns {Blockly.ASTNode} The previous element, or null if the current\n   *     node is not set or there is no previous value.\n   * @override\n   */\n  prev() {\n    const curNode = this.getCurNode();\n    if (!curNode) {\n      return null;\n    }\n    const newNode = curNode.prev();\n\n    if (newNode) {\n      this.setCurNode(newNode);\n    }\n    return newNode;\n  }\n\n  /**\n   * This is a  no-op since a flyout cursor can not go out.\n   * @returns {null} Always null.\n   * @override\n   */\n  out() {\n    return null;\n  }\n}\n\nexport const registrationType = Blockly.registry.Type.CURSOR;\nexport const registrationName = 'FlyoutCursor';\n\nBlockly.registry.register(registrationType, registrationName, FlyoutCursor);\n\nexport const pluginInfo = {\n  [registrationType]: registrationName,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The class representing a line cursor.\n * A line cursor tries to traverse the blocks and connections on a block as if\n * they were lines of code in a text editor. Previous and next traverse previous\n * connections, next connections and blocks, while in and out traverse input\n * connections and fields.\n * @author aschmiedt@google.com (Abby Schmiedt)\n */\n\nimport * as Blockly from 'blockly/core';\n\n/**\n * Class for a line cursor.\n * @constructor\n * @extends {Blockly.BasicCursor}\n */\nexport class LineCursor extends Blockly.BasicCursor {\n  /**\n   * Constructor for a line cursor.\n   */\n  constructor() {\n    super();\n  }\n\n  /**\n   * Moves the cursor to the next previous connection, next connection or block\n   * in the pre order traversal. Finds the next node in the pre order traversal.\n   * @returns {Blockly.ASTNode} The next node, or null if the current node is\n   *     not set or there is no next value.\n   * @override\n   */\n  next() {\n    const curNode = this.getCurNode();\n    if (!curNode) {\n      return null;\n    }\n    let newNode = this.getNextNode_(curNode, this.validLineNode);\n\n    // Skip the input or next value if there is a connected block.\n    if (\n      newNode &&\n      (newNode.getType() == Blockly.ASTNode.types.INPUT ||\n        newNode.getType() == Blockly.ASTNode.types.NEXT) &&\n      newNode.getLocation().targetBlock()\n    ) {\n      newNode = this.getNextNode_(newNode, this.validLineNode);\n    }\n    if (newNode) {\n      this.setCurNode(newNode);\n    }\n    return newNode;\n  }\n\n  /**\n   * Moves the cursor to the next input connection or field\n   * in the pre order traversal.\n   * @returns {Blockly.ASTNode} The next node, or null if the current node is\n   *     not set or there is no next value.\n   * @override\n   */\n  in() {\n    const curNode = this.getCurNode();\n    if (!curNode) {\n      return null;\n    }\n    const newNode = this.getNextNode_(curNode, this.validInLineNode);\n\n    if (newNode) {\n      this.setCurNode(newNode);\n    }\n    return newNode;\n  }\n  /**\n   * Moves the cursor to the previous next connection or previous connection in\n   * the pre order traversal.\n   * @returns {Blockly.ASTNode} The previous node, or null if the current node\n   *     is not set or there is no previous value.\n   * @override\n   */\n  prev() {\n    const curNode = this.getCurNode();\n    if (!curNode) {\n      return null;\n    }\n    let newNode = this.getPreviousNode_(curNode, this.validLineNode);\n\n    if (\n      newNode &&\n      (newNode.getType() == Blockly.ASTNode.types.INPUT ||\n        newNode.getType() == Blockly.ASTNode.types.NEXT) &&\n      newNode.getLocation().targetBlock()\n    ) {\n      newNode = this.getPreviousNode_(newNode, this.validLineNode);\n    }\n\n    if (newNode) {\n      this.setCurNode(newNode);\n    }\n    return newNode;\n  }\n  /**\n   * Moves the cursor to the previous input connection or field in the pre order\n   * traversal.\n   * @returns {Blockly.ASTNode} The previous node, or null if the current node\n   *     is not set or there is no previous value.\n   * @override\n   */\n  out() {\n    const curNode = this.getCurNode();\n    if (!curNode) {\n      return null;\n    }\n    const newNode = this.getPreviousNode_(curNode, this.validInLineNode);\n\n    if (newNode) {\n      this.setCurNode(newNode);\n    }\n    return newNode;\n  }\n\n  /**\n   * Decides if the previous and next methods should traverse the given node.\n   * The previous and next method only traverse previous connections, next\n   * connections and blocks.\n   * @param {Blockly.ASTNode} node The AST node to check.\n   * @returns {boolean} True if the node should be visited, false otherwise.\n   * @protected\n   */\n  validLineNode(node) {\n    if (!node) {\n      return false;\n    }\n    let isValid = false;\n    const location = node.getLocation();\n    const type = node && node.getType();\n    if (type == Blockly.ASTNode.types.BLOCK) {\n      if (location.outputConnection === null) {\n        isValid = true;\n      }\n    } else if (\n      type == Blockly.ASTNode.types.INPUT &&\n      location.type == Blockly.NEXT_STATEMENT\n    ) {\n      isValid = true;\n    } else if (type == Blockly.ASTNode.types.NEXT) {\n      isValid = true;\n    }\n    return isValid;\n  }\n\n  /**\n   * Decides if the in and out methods should traverse the given node.\n   * The in and out method only traverse fields and input connections.\n   * @param {Blockly.ASTNode} node The AST node to check whether it is valid.\n   * @returns {boolean} True if the node should be visited, false otherwise.\n   * @protected\n   */\n  validInLineNode(node) {\n    if (!node) {\n      return false;\n    }\n    let isValid = false;\n    const location = node.getLocation();\n    const type = node && node.getType();\n    if (type == Blockly.ASTNode.types.FIELD) {\n      isValid = true;\n    } else if (\n      type == Blockly.ASTNode.types.INPUT &&\n      location.type == Blockly.INPUT_VALUE\n    ) {\n      isValid = true;\n    }\n    return isValid;\n  }\n}\n\nexport const registrationName = 'LineCursor';\nexport const registrationType = Blockly.registry.Type.CURSOR;\n\nBlockly.registry.register(registrationType, registrationName, LineCursor);\n\nexport const pluginInfo = {\n  [registrationType]: registrationName,\n};\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Holds all methods necessary to use Blockly through the\n * keyboard.\n * @author aschmiedt@google.com (Abby Schmiedt)\n */\n\nimport * as Blockly from 'blockly/core';\nimport * as Constants from './constants';\nimport {\n  registrationName as cursorRegistrationName,\n  registrationType as cursorRegistrationType,\n} from './flyout_cursor';\n\n/**\n * Class that holds all methods necessary for keyboard navigation to work.\n */\nexport class Navigation {\n  /**\n   * Constructor for keyboard navigation.\n   */\n  constructor() {\n    /**\n     * Object holding the location of the cursor for each workspace.\n     * Possible locations of the cursor are: workspace, flyout or toolbox.\n     * @type {Object<string,Constants.STATE>}\n     * @protected\n     */\n    this.workspaceStates = {};\n\n    /**\n     * An optional method that allows a developer to customize how to handle\n     * logs, warnings, and errors. The first argument is one of 'log', 'warn',\n     * or 'error'. The second argument is the message.\n     * @type {?function(Constants.LOGGING_MSG_TYPE, string)}\n     * @public\n     */\n    this.loggingCallback = null;\n\n    /**\n     * The distance to move the cursor when the cursor is on the workspace.\n     * @type {number}\n     * @public\n     */\n    this.WS_MOVE_DISTANCE = 40;\n\n    /**\n     * The name of the marker to use for keyboard navigation.\n     * @type {string}\n     * @public\n     */\n    this.MARKER_NAME = 'local_marker_1';\n\n    /**\n     * The default coordinate to use when focusing on the workspace and no\n     * blocks are present. In pixel coordinates, but will be converted to\n     * workspace coordinates when used to position the cursor.\n     * @type {!Blockly.utils.Coordinate}\n     * @public\n     */\n    this.DEFAULT_WS_COORDINATE = new Blockly.utils.Coordinate(100, 100);\n\n    /**\n     * The default coordinate to use when moving the cursor to the workspace\n     * after a block has been deleted. In pixel coordinates, but will be\n     * converted to workspace coordinates when used to position the cursor.\n     * @type {!Blockly.utils.Coordinate}\n     * @public\n     */\n    this.WS_COORDINATE_ON_DELETE = new Blockly.utils.Coordinate(100, 100);\n\n    /**\n     * Wrapper for method that deals with workspace changes.\n     * Used for removing change listener.\n     * @type {Function}\n     * @protected\n     */\n    this.wsChangeWrapper = this.workspaceChangeListener.bind(this);\n\n    /**\n     * Wrapper for method that deals with flyout changes.\n     * Used for removing change listener.\n     * @type {Function}\n     * @protected\n     */\n    this.flyoutChangeWrapper = this.flyoutChangeListener.bind(this);\n\n    /**\n     * The list of registered workspaces.\n     * Used when removing change listeners in dispose.\n     * @type {!Array<!Blockly.WorkspaceSvg>}\n     * @protected\n     */\n    this.workspaces = [];\n  }\n\n  /**\n   * Adds all necessary change listeners and markers to a workspace for keyboard\n   * navigation to work. This must be called for keyboard navigation to work\n   * on a workspace.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to add keyboard\n   *     navigation to.\n   * @public\n   */\n  addWorkspace(workspace) {\n    this.workspaces.push(workspace);\n    const flyout = workspace.getFlyout();\n    workspace\n      .getMarkerManager()\n      .registerMarker(this.MARKER_NAME, new Blockly.Marker());\n    workspace.addChangeListener(this.wsChangeWrapper);\n\n    if (flyout) {\n      this.addFlyout(flyout);\n    }\n  }\n\n  /**\n   * Removes all keyboard navigation change listeners and markers.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to remove keyboard\n   *     navigation from.\n   * @public\n   */\n  removeWorkspace(workspace) {\n    const workspaceIdx = this.workspaces.indexOf(workspace);\n    const flyout = workspace.getFlyout();\n\n    if (workspace.getCursor()) {\n      this.disableKeyboardAccessibility(workspace);\n    }\n\n    if (workspaceIdx > -1) {\n      this.workspaces.splice(workspaceIdx, 1);\n    }\n    if (workspace.getMarkerManager()) {\n      workspace.getMarkerManager().unregisterMarker(this.MARKER_NAME);\n    }\n    workspace.removeChangeListener(this.wsChangeWrapper);\n\n    if (flyout) {\n      this.removeFlyout(flyout);\n    }\n  }\n\n  /**\n   * Sets the state for the given workspace.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to set the state on.\n   * @param {!Constants.STATE} state The navigation state.\n   * @protected\n   */\n  setState(workspace, state) {\n    this.workspaceStates[workspace.id] = state;\n  }\n\n  /**\n   * Gets the navigation state of the current workspace.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to get the state of.\n   * @returns {!Constants.STATE} The state of the given workspace.\n   * @package\n   */\n  getState(workspace) {\n    return this.workspaceStates[workspace.id];\n  }\n\n  /**\n   * Gets the marker created for keyboard navigation.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to get the marker\n   *     from.\n   * @returns {?Blockly.Marker} The marker created for keyboard navigation.\n   * @protected\n   */\n  getMarker(workspace) {\n    return workspace.getMarker(this.MARKER_NAME);\n  }\n\n  /**\n   * Adds all event listeners and cursors to the flyout that are needed for\n   * keyboard navigation to work.\n   * @param {!Blockly.IFlyout} flyout The flyout to add a cursor and change\n   *     listeners to.\n   * @protected\n   */\n  addFlyout(flyout) {\n    const flyoutWorkspace = flyout.getWorkspace();\n    flyoutWorkspace.addChangeListener(this.flyoutChangeWrapper);\n    const FlyoutCursorClass = Blockly.registry.getClass(\n      cursorRegistrationType,\n      cursorRegistrationName,\n    );\n    flyoutWorkspace.getMarkerManager().setCursor(new FlyoutCursorClass());\n  }\n\n  /**\n   * Removes all change listeners from the flyout that are needed for\n   * keyboard navigation to work.\n   * @param {!Blockly.IFlyout} flyout The flyout to add a cursor and event\n   *     listeners to.\n   * @protected\n   */\n  removeFlyout(flyout) {\n    const flyoutWorkspace = flyout.getWorkspace();\n    flyoutWorkspace.removeChangeListener(this.flyoutChangeWrapper);\n  }\n\n  /**\n   * Updates the state of keyboard navigation and the position of the cursor\n   * based on workspace events.\n   * @param {!Blockly.Events.Abstract} e The Blockly event to process.\n   * @protected\n   */\n  workspaceChangeListener(e) {\n    const workspace = Blockly.Workspace.getById(e.workspaceId);\n    if (!workspace || !workspace.keyboardAccessibilityMode) {\n      return;\n    }\n    switch (e.type) {\n      case Blockly.Events.DELETE:\n        this.handleBlockDeleteByDrag(workspace, e);\n        break;\n      case Blockly.Events.BLOCK_CHANGE:\n        if (e.element === 'mutation') {\n          this.handleBlockMutation(\n            workspace,\n            /** @type {Blockly.Events.BlockChange} */ (e),\n          );\n        }\n        break;\n      case Blockly.Events.CLICK:\n        this.handleWorkspaceClick(\n          workspace,\n          /** @type {Blockly.Events.Click} */ (e),\n        );\n        break;\n      case Blockly.Events.TOOLBOX_ITEM_SELECT:\n        this.handleToolboxCategoryClick(\n          workspace,\n          /** @type {Blockly.Events.ToolboxItemSelect} */ (e),\n        );\n        break;\n      case Blockly.Events.BLOCK_CREATE:\n        this.handleBlockCreate(workspace, e);\n    }\n  }\n\n  /**\n   * Updates the state of keyboard navigation and the position of the cursor\n   * based on events emitted from the flyout's workspace.\n   * @param {!Blockly.Events.Abstract} e The Blockly event to process.\n   * @protected\n   */\n  flyoutChangeListener(e) {\n    const flyoutWorkspace = Blockly.Workspace.getById(e.workspaceId);\n    const mainWorkspace = flyoutWorkspace.targetWorkspace;\n    const flyout = mainWorkspace.getFlyout();\n\n    // This is called for simple toolboxes and for toolboxes that have a flyout\n    // that does not close. Autoclosing flyouts close before we need to focus\n    // the cursor on the block that was clicked.\n    if (\n      mainWorkspace &&\n      mainWorkspace.keyboardAccessibilityMode &&\n      !flyout.autoClose\n    ) {\n      if (e.type === Blockly.Events.CLICK && e.targetType === 'block') {\n        const block = flyoutWorkspace.getBlockById(e.blockId);\n        this.handleBlockClickInFlyout(mainWorkspace, block);\n      } else if (e.type === Blockly.Events.SELECTED) {\n        const block = flyoutWorkspace.getBlockById(e.newElementId);\n        this.handleBlockClickInFlyout(mainWorkspace, block);\n      }\n    }\n  }\n\n  /**\n   * Moves the cursor to the workspace if a block has been dragged from a simple\n   * toolbox. For a category toolbox this is handled in\n   * handleToolboxCategoryClick_.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace the cursor belongs\n   *     to.\n   * @param {!Blockly.Events.Abstract} e The Blockly event to process.\n   * @protected\n   */\n  handleBlockCreate(workspace, e) {\n    if (this.getState(workspace) === Constants.STATE.FLYOUT) {\n      this.resetFlyout(workspace, !!workspace.getToolbox());\n      this.setState(workspace, Constants.STATE.WORKSPACE);\n    }\n  }\n\n  /**\n   * Moves the cursor to the block level when the block the cursor is on\n   * mutates.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace the cursor belongs\n   *     to.\n   * @param {!Blockly.Events.BlockChange} e The Blockly event to process.\n   * @protected\n   */\n  handleBlockMutation(workspace, e) {\n    const mutatedBlockId = e.blockId;\n    const cursor = workspace.getCursor();\n    if (cursor) {\n      const curNode = cursor.getCurNode();\n      const block = curNode ? curNode.getSourceBlock() : null;\n      if (block && block.id === mutatedBlockId) {\n        cursor.setCurNode(Blockly.ASTNode.createBlockNode(block));\n      }\n    }\n  }\n\n  /**\n   * Moves the cursor to the workspace when a user clicks on the workspace.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace the cursor belongs\n   *     to.\n   * @param {!Blockly.Events.Click} e The Blockly event to process.\n   * @protected\n   */\n  handleWorkspaceClick(workspace, e) {\n    const workspaceState = this.getState(workspace);\n    if (workspaceState !== Constants.STATE.WORKSPACE) {\n      this.resetFlyout(workspace, !!workspace.getToolbox());\n      this.setState(workspace, Constants.STATE.WORKSPACE);\n    }\n  }\n\n  /**\n   * Moves the cursor to the toolbox when a user clicks on a toolbox category.\n   * Moves the cursor to the workspace if theh user closes the toolbox category.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace the toolbox is on.\n   * @param {!Blockly.Events.ToolboxItemSelect} e The event emitted from the\n   *     workspace.\n   * @protected\n   */\n  handleToolboxCategoryClick(workspace, e) {\n    const workspaceState = this.getState(workspace);\n    if (e.newItem && workspaceState !== Constants.STATE.TOOLBOX) {\n      // If the toolbox category was just clicked, focus on the toolbox.\n      this.focusToolbox(workspace);\n    } else if (!e.newItem) {\n      // If the toolbox was closed, focus on the workspace.\n      this.resetFlyout(workspace, !!workspace.getToolbox());\n      this.setState(workspace, Constants.STATE.WORKSPACE);\n    }\n  }\n\n  /**\n   * Moves the cursor to the workspace when its parent block is deleted by\n   * being dragged to the flyout or to the trashcan.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace the block was on.\n   * @param {!Blockly.Events.Delete} e The event emitted when a block is\n   *     deleted.\n   * @protected\n   */\n  handleBlockDeleteByDrag(workspace, e) {\n    const deletedBlockId = e.blockId;\n    const ids = e.ids;\n    const cursor = workspace.getCursor();\n\n    // Make sure the cursor is on a block.\n    if (\n      !cursor ||\n      !cursor.getCurNode() ||\n      !cursor.getCurNode().getSourceBlock()\n    ) {\n      return;\n    }\n\n    const curNode = cursor.getCurNode();\n    const sourceBlock = curNode.getSourceBlock();\n    if (sourceBlock.id === deletedBlockId || ids.indexOf(sourceBlock.id) > -1) {\n      cursor.setCurNode(\n        Blockly.ASTNode.createWorkspaceNode(\n          workspace,\n          this.WS_COORDINATE_ON_DELETE,\n        ),\n      );\n    }\n  }\n\n  /**\n   * Handles when a user clicks on a block in the flyout by moving the cursor\n   * to that stack of blocks and setting the state of navigation to the flyout.\n   * @param {!Blockly.WorkspaceSvg} mainWorkspace The workspace the user clicked\n   *     on.\n   * @param {!Blockly.BlockSvg} block The block the user clicked on.\n   * @protected\n   */\n  handleBlockClickInFlyout(mainWorkspace, block) {\n    if (!block) {\n      return;\n    }\n    if (block.isShadow()) {\n      block = /** @type {Blockly.BlockSvg}*/ (block.getParent());\n    }\n    this.getFlyoutCursor(mainWorkspace).setCurNode(\n      Blockly.ASTNode.createStackNode(block),\n    );\n    this.setState(mainWorkspace, Constants.STATE.FLYOUT);\n  }\n\n  /**\n   * Moves the cursor to the appropriate location before a block is deleted.\n   * This is used when the user deletes a block using the delete or backspace\n   * key.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace the block is being\n   *     deleted on.\n   * @param {!Blockly.BlockSvg} deletedBlock The block that is being deleted.\n   * @package\n   */\n  moveCursorOnBlockDelete(workspace, deletedBlock) {\n    if (!workspace || !workspace.getCursor()) {\n      return;\n    }\n    const cursor = workspace.getCursor();\n    const curNode = cursor.getCurNode();\n    const block = curNode ? curNode.getSourceBlock() : null;\n\n    if (block === deletedBlock) {\n      // If the block has a parent move the cursor to their connection point.\n      if (block.getParent()) {\n        const topConnection =\n          block.previousConnection || block.outputConnection;\n        if (topConnection) {\n          cursor.setCurNode(\n            Blockly.ASTNode.createConnectionNode(\n              topConnection.targetConnection,\n            ),\n          );\n        }\n      } else {\n        // If the block is by itself move the cursor to the workspace.\n        cursor.setCurNode(\n          Blockly.ASTNode.createWorkspaceNode(\n            block.workspace,\n            block.getRelativeToSurfaceXY(),\n          ),\n        );\n      }\n      // If the cursor is on a block whose parent is being deleted, move the\n      // cursor to the workspace.\n    } else if (block && deletedBlock.getChildren(false).indexOf(block) > -1) {\n      cursor.setCurNode(\n        Blockly.ASTNode.createWorkspaceNode(\n          block.workspace,\n          block.getRelativeToSurfaceXY(),\n        ),\n      );\n    }\n  }\n\n  /**\n   * Sets the navigation state to toolbox and selects the first category in the\n   * toolbox. No-op if a toolbox does not exist on the given workspace.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to get the toolbox\n   *     on.\n   * @package\n   */\n  focusToolbox(workspace) {\n    const toolbox = workspace.getToolbox();\n    if (!toolbox) {\n      return;\n    }\n\n    this.setState(workspace, Constants.STATE.TOOLBOX);\n    this.resetFlyout(workspace, false /* shouldHide */);\n\n    if (!this.getMarker(workspace).getCurNode()) {\n      this.markAtCursor(workspace);\n    }\n\n    if (!toolbox.getSelectedItem()) {\n      // Find the first item that is selectable.\n      const toolboxItems = toolbox.getToolboxItems();\n      for (let i = 0, toolboxItem; (toolboxItem = toolboxItems[i]); i++) {\n        if (toolboxItem.isSelectable()) {\n          toolbox.selectItemByPosition(i);\n          break;\n        }\n      }\n    }\n  }\n\n  /**\n   * Sets the navigation state to flyout and moves the cursor to the first\n   * block in the flyout.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace the flyout is on.\n   * @package\n   */\n  focusFlyout(workspace) {\n    const flyout = workspace.getFlyout();\n\n    this.setState(workspace, Constants.STATE.FLYOUT);\n\n    if (!this.getMarker(workspace).getCurNode()) {\n      this.markAtCursor(workspace);\n    }\n\n    if (flyout && flyout.getWorkspace()) {\n      const topBlocks = flyout.getWorkspace().getTopBlocks(true);\n      if (topBlocks.length > 0) {\n        const astNode = Blockly.ASTNode.createStackNode(topBlocks[0]);\n        this.getFlyoutCursor(workspace).setCurNode(astNode);\n      }\n    }\n  }\n\n  /**\n   * Sets the navigation state to workspace and moves the cursor to either the\n   * top block on a workspace or to the workspace.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to focus on.\n   * @package\n   */\n  focusWorkspace(workspace) {\n    workspace.hideChaff();\n    const reset = !!workspace.getToolbox();\n\n    this.resetFlyout(workspace, reset);\n    this.setState(workspace, Constants.STATE.WORKSPACE);\n    this.setCursorOnWorkspaceFocus(workspace);\n  }\n\n  /**\n   * Moves the cursor to the top connection point on on the first top block.\n   * If the workspace is empty, moves the cursor to the default location on\n   * the workspace.\n   * @param {!Blockly.WorkspaceSvg} workspace The main Blockly workspace.\n   * @protected\n   */\n  setCursorOnWorkspaceFocus(workspace) {\n    const topBlocks = workspace.getTopBlocks(true);\n    const cursor = workspace.getCursor();\n    const wsCoordinates = new Blockly.utils.Coordinate(\n      this.DEFAULT_WS_COORDINATE.x / workspace.scale,\n      this.DEFAULT_WS_COORDINATE.y / workspace.scale,\n    );\n    if (topBlocks.length > 0) {\n      cursor.setCurNode(Blockly.ASTNode.createTopNode(topBlocks[0]));\n    } else {\n      const wsNode = Blockly.ASTNode.createWorkspaceNode(\n        workspace,\n        wsCoordinates,\n      );\n      cursor.setCurNode(wsNode);\n    }\n  }\n\n  /**\n   * Gets the cursor on the flyout's workspace.\n   * @param {!Blockly.WorkspaceSvg} workspace The main workspace the flyout is\n   *     on.\n   * @returns {?Blockly.FlyoutCursor} The flyout's cursor or null if no flyout\n   *     exists.\n   * @protected\n   */\n  getFlyoutCursor(workspace) {\n    const flyout = workspace.getFlyout();\n    const cursor = flyout ? flyout.getWorkspace().getCursor() : null;\n\n    return /** @type {?Blockly.FlyoutCursor} */ (cursor);\n  }\n\n  /**\n   * Inserts a block from the flyout.\n   * Tries to find a connection on the block to connect to the marked\n   * location. If no connection has been marked, or there is not a compatible\n   * connection then the block is placed on the workspace.\n   * @param {!Blockly.WorkspaceSvg} workspace The main workspace. The workspace\n   *     the block will be placed on.\n   * @package\n   */\n  insertFromFlyout(workspace) {\n    const newBlock = this.createNewBlock(workspace);\n    if (!newBlock) {\n      return;\n    }\n    const markerNode = this.getMarker(workspace).getCurNode();\n    if (\n      !this.tryToConnectMarkerAndCursor(\n        workspace,\n        markerNode,\n        Blockly.ASTNode.createBlockNode(newBlock),\n      )\n    ) {\n      this.warn(\n        'Something went wrong while inserting a block from the flyout.',\n      );\n    }\n\n    this.focusWorkspace(workspace);\n    workspace.getCursor().setCurNode(Blockly.ASTNode.createTopNode(newBlock));\n    this.removeMark(workspace);\n  }\n\n  /**\n   * Creates a new block based on the current block the flyout cursor is on.\n   * @param {!Blockly.WorkspaceSvg} workspace The main workspace. The workspace\n   *     the block will be placed on.\n   * @returns {?Blockly.BlockSvg} The newly created block.\n   * @protected\n   */\n  createNewBlock(workspace) {\n    const flyout = workspace.getFlyout();\n    if (!flyout || !flyout.isVisible()) {\n      this.warn(\n        'Trying to insert from the flyout when the flyout does not ' +\n          ' exist or is not visible',\n      );\n      return null;\n    }\n\n    const curBlock = /** @type {!Blockly.BlockSvg} */ (\n      this.getFlyoutCursor(workspace).getCurNode().getLocation()\n    );\n    if (!curBlock.isEnabled()) {\n      this.warn(\"Can't insert a disabled block.\");\n      return null;\n    }\n\n    const newBlock = flyout.createBlock(curBlock);\n    // Render to get the sizing right.\n    newBlock.render();\n    // Connections are not tracked when the block is first created.  Normally\n    // there's enough time for them to become tracked in the user's mouse\n    // movements, but not here.\n    newBlock.setConnectionTracking(true);\n    return newBlock;\n  }\n\n  /**\n   * Hides the flyout cursor and optionally hides the flyout.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace.\n   * @param {boolean} shouldHide True if the flyout should be hidden.\n   * @protected\n   */\n  resetFlyout(workspace, shouldHide) {\n    if (this.getFlyoutCursor(workspace)) {\n      this.getFlyoutCursor(workspace).hide();\n      if (shouldHide) {\n        workspace.getFlyout().hide();\n      }\n    }\n  }\n\n  /**\n   * Connects the location of the marker and the location of the cursor.\n   * No-op if the marker or cursor node are null.\n   * @param {!Blockly.WorkspaceSvg} workspace The main workspace.\n   * @returns {boolean} True if the cursor and marker locations were connected,\n   *     false otherwise.\n   * @package\n   */\n  connectMarkerAndCursor(workspace) {\n    const markerNode = this.getMarker(workspace).getCurNode();\n    const cursorNode = workspace.getCursor().getCurNode();\n\n    if (markerNode && cursorNode) {\n      return this.tryToConnectMarkerAndCursor(\n        workspace,\n        markerNode,\n        cursorNode,\n      );\n    }\n    return false;\n  }\n\n  /**\n   * Tries to connect the given marker and cursor node.\n   * @param {!Blockly.WorkspaceSvg} workspace The main workspace.\n   * @param {!Blockly.ASTNode} markerNode The node to try to connect to.\n   * @param {!Blockly.ASTNode} cursorNode The node to connect to the markerNode.\n   * @returns {boolean} True if the key was handled; false if something went\n   *     wrong.\n   * @protected\n   */\n  tryToConnectMarkerAndCursor(workspace, markerNode, cursorNode) {\n    if (!this.logConnectionWarning(markerNode, cursorNode)) {\n      return false;\n    }\n\n    const markerType = markerNode.getType();\n    const cursorType = cursorNode.getType();\n\n    const cursorLoc = cursorNode.getLocation();\n    const markerLoc = markerNode.getLocation();\n    if (markerNode.isConnection() && cursorNode.isConnection()) {\n      const cursorConnection = /** @type {!Blockly.RenderedConnection} */ (\n        cursorLoc\n      );\n      const markerConnection = /** @type {!Blockly.RenderedConnection} */ (\n        markerLoc\n      );\n      return this.connect(cursorConnection, markerConnection);\n    } else if (\n      markerNode.isConnection() &&\n      (cursorType == Blockly.ASTNode.types.BLOCK ||\n        cursorType == Blockly.ASTNode.types.STACK)\n    ) {\n      const cursorBlock = /** @type {!Blockly.BlockSvg} */ (cursorLoc);\n      const markerConnection = /** @type {!Blockly.RenderedConnection} */ (\n        markerLoc\n      );\n      return this.insertBlock(cursorBlock, markerConnection);\n    } else if (markerType == Blockly.ASTNode.types.WORKSPACE) {\n      const block = cursorNode ? cursorNode.getSourceBlock() : null;\n      return this.moveBlockToWorkspace(\n        /** @type {Blockly.BlockSvg} */ (block),\n        markerNode,\n      );\n    }\n    this.warn('Unexpected state in tryToConnectMarkerAndCursor.');\n    return false;\n  }\n\n  /**\n   * Warns the user if the given cursor or marker node can not be connected.\n   * @param {!Blockly.ASTNode} markerNode The node to try to connect to.\n   * @param {!Blockly.ASTNode} cursorNode The node to connect to the markerNode.\n   * @returns {boolean} True if the marker and cursor are valid types, false\n   *     otherwise.\n   * @protected\n   */\n  logConnectionWarning(markerNode, cursorNode) {\n    if (!markerNode) {\n      this.warn('Cannot insert with no marked node.');\n      return false;\n    }\n\n    if (!cursorNode) {\n      this.warn('Cannot insert with no cursor node.');\n      return false;\n    }\n    const markerType = markerNode.getType();\n    const cursorType = cursorNode.getType();\n\n    // Check the marker for invalid types.\n    if (markerType == Blockly.ASTNode.types.FIELD) {\n      this.warn('Should not have been able to mark a field.');\n      return false;\n    } else if (markerType == Blockly.ASTNode.types.BLOCK) {\n      this.warn('Should not have been able to mark a block.');\n      return false;\n    } else if (markerType == Blockly.ASTNode.types.STACK) {\n      this.warn('Should not have been able to mark a stack.');\n      return false;\n    }\n\n    // Check the cursor for invalid types.\n    if (cursorType == Blockly.ASTNode.types.FIELD) {\n      this.warn('Cannot attach a field to anything else.');\n      return false;\n    } else if (cursorType == Blockly.ASTNode.types.WORKSPACE) {\n      this.warn('Cannot attach a workspace to anything else.');\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Disconnects the block from its parent and moves it to the position of the\n   * workspace node.\n   * @param {?Blockly.BlockSvg} block The block to be moved to the workspace.\n   * @param {!Blockly.ASTNode} wsNode The workspace node holding the position\n   *     the block will be moved to.\n   * @returns {boolean} True if the block can be moved to the workspace,\n   *     false otherwise.\n   * @protected\n   */\n  moveBlockToWorkspace(block, wsNode) {\n    if (!block) {\n      return false;\n    }\n    if (block.isShadow()) {\n      this.warn('Cannot move a shadow block to the workspace.');\n      return false;\n    }\n    if (block.getParent()) {\n      block.unplug(false);\n    }\n    block.moveTo(wsNode.getWsCoordinate());\n    return true;\n  }\n\n  /**\n   * Disconnects the child block from its parent block. No-op if the two given\n   * connections are unrelated.\n   * @param {!Blockly.RenderedConnection} movingConnection The connection that\n   *     is being moved.\n   * @param {!Blockly.RenderedConnection} destConnection The connection to be\n   *     moved to.\n   * @protected\n   */\n  disconnectChild(movingConnection, destConnection) {\n    const movingBlock = movingConnection.getSourceBlock();\n    const destBlock = destConnection.getSourceBlock();\n    let inferiorConnection;\n\n    if (movingBlock.getRootBlock() === destBlock.getRootBlock()) {\n      if (movingBlock.getDescendants(false).indexOf(destBlock) > -1) {\n        inferiorConnection = this.getInferiorConnection(destConnection);\n        if (inferiorConnection) {\n          inferiorConnection.disconnect();\n        }\n      } else {\n        inferiorConnection = this.getInferiorConnection(movingConnection);\n        if (inferiorConnection) {\n          inferiorConnection.disconnect();\n        }\n      }\n    }\n  }\n\n  /**\n   * Tries to connect the  given connections.\n   *\n   * If the given connections are not compatible try finding compatible\n   * connections on the source blocks of the given connections.\n   * @param {?Blockly.RenderedConnection} movingConnection The connection that\n   *     is being moved.\n   * @param {?Blockly.RenderedConnection} destConnection The connection to be\n   *     moved to.\n   * @returns {boolean} True if the two connections or their target connections\n   *     were connected, false otherwise.\n   * @protected\n   */\n  connect(movingConnection, destConnection) {\n    if (!movingConnection || !destConnection) {\n      return false;\n    }\n\n    const movingInferior = this.getInferiorConnection(movingConnection);\n    const destSuperior = this.getSuperiorConnection(destConnection);\n\n    const movingSuperior = this.getSuperiorConnection(movingConnection);\n    const destInferior = this.getInferiorConnection(destConnection);\n\n    if (\n      movingInferior &&\n      destSuperior &&\n      this.moveAndConnect(movingInferior, destSuperior)\n    ) {\n      return true;\n      // Try swapping the inferior and superior connections on the blocks.\n    } else if (\n      movingSuperior &&\n      destInferior &&\n      this.moveAndConnect(movingSuperior, destInferior)\n    ) {\n      return true;\n    } else if (this.moveAndConnect(movingConnection, destConnection)) {\n      return true;\n    } else {\n      const checker = movingConnection.getConnectionChecker();\n      const reason = checker.canConnectWithReason(\n        movingConnection,\n        destConnection,\n        false,\n      );\n      this.warn(\n        'Connection failed with error: ' +\n          checker.getErrorMessage(reason, movingConnection, destConnection),\n      );\n      return false;\n    }\n  }\n\n  /**\n   * Finds the inferior connection on the source block if the given connection\n   * is superior.\n   * @param {?Blockly.RenderedConnection} connection The connection trying to be\n   *     connected.\n   * @returns {?Blockly.RenderedConnection} The inferior connection or null if\n   *     none exists.\n   * @protected\n   */\n  getInferiorConnection(connection) {\n    const block = /** @type{!Blockly.BlockSvg} */ (connection.getSourceBlock());\n    if (!connection.isSuperior()) {\n      return connection;\n    } else if (block.previousConnection) {\n      return block.previousConnection;\n    } else if (block.outputConnection) {\n      return block.outputConnection;\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Finds a superior connection on the source block if the given connection is\n   * inferior.\n   * @param {?Blockly.RenderedConnection} connection The connection trying to be\n   *     connected.\n   * @returns {?Blockly.RenderedConnection} The superior connection or null if\n   *     none exists.\n   * @protected\n   */\n  getSuperiorConnection(connection) {\n    if (connection.isSuperior()) {\n      return connection;\n    } else if (connection.targetConnection) {\n      return connection.targetConnection;\n    }\n    return null;\n  }\n\n  /**\n   * Moves the moving connection to the target connection and connects them.\n   * @param {?Blockly.RenderedConnection} movingConnection The connection that\n   *     is being moved.\n   * @param {?Blockly.RenderedConnection} destConnection The connection to be\n   *     moved to.\n   * @returns {boolean} True if the connections were connected, false otherwise.\n   * @protected\n   */\n  moveAndConnect(movingConnection, destConnection) {\n    if (!movingConnection || !destConnection) {\n      return false;\n    }\n    const movingBlock = movingConnection.getSourceBlock();\n    const checker = movingConnection.getConnectionChecker();\n\n    if (\n      checker.canConnect(movingConnection, destConnection, false) &&\n      !destConnection.getSourceBlock().isShadow()\n    ) {\n      this.disconnectChild(movingConnection, destConnection);\n\n      // Position the root block near the connection so it does not move the\n      // other block when they are connected.\n      if (!destConnection.isSuperior()) {\n        const rootBlock = movingBlock.getRootBlock();\n\n        const originalOffsetToTarget = {\n          x: destConnection.x - movingConnection.x,\n          y: destConnection.y - movingConnection.y,\n        };\n        const originalOffsetInBlock = movingConnection\n          .getOffsetInBlock()\n          .clone();\n        rootBlock.positionNearConnection(\n          movingConnection,\n          originalOffsetToTarget,\n          originalOffsetInBlock,\n        );\n      }\n      destConnection.connect(movingConnection);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Tries to connect the given block to the destination connection, making an\n   * intelligent guess about which connection to use on the moving block.\n   * @param {!Blockly.BlockSvg} block The block to move.\n   * @param {!Blockly.RenderedConnection} destConnection The connection to\n   *     connect to.\n   * @returns {boolean} Whether the connection was successful.\n   * @protected\n   */\n  insertBlock(block, destConnection) {\n    switch (destConnection.type) {\n      case Blockly.PREVIOUS_STATEMENT:\n        if (this.connect(block.nextConnection, destConnection)) {\n          return true;\n        }\n        break;\n      case Blockly.NEXT_STATEMENT:\n        if (this.connect(block.previousConnection, destConnection)) {\n          return true;\n        }\n        break;\n      case Blockly.INPUT_VALUE:\n        if (this.connect(block.outputConnection, destConnection)) {\n          return true;\n        }\n        break;\n      case Blockly.OUTPUT_VALUE:\n        for (let i = 0; i < block.inputList.length; i++) {\n          const inputConnection = /** @type {Blockly.RenderedConnection} */ (\n            block.inputList[i].connection\n          );\n          if (\n            inputConnection &&\n            inputConnection.type === Blockly.INPUT_VALUE &&\n            this.connect(inputConnection, destConnection)\n          ) {\n            return true;\n          }\n        }\n        // If there are no input values pass the output and destination\n        // connections to connect_ to find a way to connect the two.\n        if (\n          block.outputConnection &&\n          this.connect(block.outputConnection, destConnection)\n        ) {\n          return true;\n        }\n        break;\n    }\n    this.warn('This block can not be inserted at the marked location.');\n    return false;\n  }\n\n  /**\n   * Disconnects the connection that the cursor is pointing to, and bump blocks.\n   * This is a no-op if the connection cannot be broken or if the cursor is not\n   * pointing to a connection.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace.\n   * @package\n   */\n  disconnectBlocks(workspace) {\n    const curNode = workspace.getCursor().getCurNode();\n    if (!curNode.isConnection()) {\n      this.log(\n        'Cannot disconnect blocks when the cursor is not on a connection',\n      );\n      return;\n    }\n    const curConnection = /** @type {!Blockly.RenderedConnection} */ (\n      curNode.getLocation()\n    );\n    if (!curConnection.isConnected()) {\n      this.log('Cannot disconnect unconnected connection');\n      return;\n    }\n    const superiorConnection = curConnection.isSuperior()\n      ? curConnection\n      : curConnection.targetConnection;\n\n    const inferiorConnection = curConnection.isSuperior()\n      ? curConnection.targetConnection\n      : curConnection;\n\n    if (inferiorConnection.getSourceBlock().isShadow()) {\n      this.log('Cannot disconnect a shadow block');\n      return;\n    }\n    superiorConnection.disconnect();\n    inferiorConnection.bumpAwayFrom(superiorConnection);\n\n    const rootBlock = superiorConnection.getSourceBlock().getRootBlock();\n    rootBlock.bringToFront();\n\n    const connectionNode =\n      Blockly.ASTNode.createConnectionNode(superiorConnection);\n    workspace.getCursor().setCurNode(connectionNode);\n  }\n\n  /**\n   * Moves the marker to the cursor's current location.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace.\n   * @protected\n   */\n  markAtCursor(workspace) {\n    this.getMarker(workspace).setCurNode(workspace.getCursor().getCurNode());\n  }\n\n  /**\n   * Removes the marker from its current location and hide it.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace.\n   * @protected\n   */\n  removeMark(workspace) {\n    const marker = this.getMarker(workspace);\n    marker.setCurNode(null);\n    marker.hide();\n  }\n\n  /**\n   * Enables accessibility mode.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to enable keyboard\n   *     accessibility mode on.\n   * @package\n   */\n  enableKeyboardAccessibility(workspace) {\n    if (\n      this.workspaces.indexOf(workspace) > -1 &&\n      !workspace.keyboardAccessibilityMode\n    ) {\n      workspace.keyboardAccessibilityMode = true;\n      this.focusWorkspace(workspace);\n    }\n  }\n\n  /**\n   * Disables accessibility mode.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to disable keyboard\n   *     accessibility mode on.\n   * @package\n   */\n  disableKeyboardAccessibility(workspace) {\n    if (\n      this.workspaces.indexOf(workspace) > -1 &&\n      workspace.keyboardAccessibilityMode\n    ) {\n      workspace.keyboardAccessibilityMode = false;\n      workspace.getCursor().hide();\n      this.getMarker(workspace).hide();\n      if (this.getFlyoutCursor(workspace)) {\n        this.getFlyoutCursor(workspace).hide();\n      }\n    }\n  }\n\n  /**\n   * Navigation log handler. If loggingCallback is defined, use it.\n   * Otherwise just log to the console.log.\n   * @param {string} msg The message to log.\n   * @protected\n   */\n  log(msg) {\n    if (this.loggingCallback) {\n      this.loggingCallback(Constants.LOGGING_MSG_TYPE.LOG, msg);\n    } else {\n      console.log(msg);\n    }\n  }\n\n  /**\n   * Navigation warning handler. If loggingCallback is defined, use it.\n   * Otherwise call console.warn.\n   * @param {string} msg The warning message.\n   * @protected\n   */\n  warn(msg) {\n    if (this.loggingCallback) {\n      this.loggingCallback(Constants.LOGGING_MSG_TYPE.WARN, msg);\n    } else {\n      console.warn(msg);\n    }\n  }\n\n  /**\n   * Navigation error handler. If loggingCallback is defined, use it.\n   * Otherwise call console.error.\n   * @param {string} msg The error message.\n   * @protected\n   */\n  error(msg) {\n    if (this.loggingCallback) {\n      this.loggingCallback(Constants.LOGGING_MSG_TYPE.ERROR, msg);\n    } else {\n      console.error(msg);\n    }\n  }\n\n  /**\n   * Moves the workspace cursor in the given direction.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace the cursor is on.\n   * @param {number} xDirection -1 to move cursor left. 1 to move cursor right.\n   * @param {number} yDirection -1 to move cursor up. 1 to move cursor down.\n   * @returns {boolean} True if the current node is a workspace, false\n   *     otherwise.\n   * @package\n   */\n  moveWSCursor(workspace, xDirection, yDirection) {\n    const cursor = workspace.getCursor();\n    const curNode = workspace.getCursor().getCurNode();\n\n    if (curNode.getType() !== Blockly.ASTNode.types.WORKSPACE) {\n      return false;\n    }\n\n    const wsCoord = curNode.getWsCoordinate();\n    const newX = xDirection * this.WS_MOVE_DISTANCE + wsCoord.x;\n    const newY = yDirection * this.WS_MOVE_DISTANCE + wsCoord.y;\n\n    cursor.setCurNode(\n      Blockly.ASTNode.createWorkspaceNode(\n        workspace,\n        new Blockly.utils.Coordinate(newX, newY),\n      ),\n    );\n    return true;\n  }\n\n  /**\n   * Handles hitting the enter key on the workspace.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace.\n   * @package\n   */\n  handleEnterForWS(workspace) {\n    const cursor = workspace.getCursor();\n    const curNode = cursor.getCurNode();\n    const nodeType = curNode.getType();\n    if (nodeType == Blockly.ASTNode.types.FIELD) {\n      /** @type {!Blockly.Field} */ (curNode.getLocation()).showEditor();\n    } else if (\n      curNode.isConnection() ||\n      nodeType == Blockly.ASTNode.types.WORKSPACE\n    ) {\n      this.markAtCursor(workspace);\n    } else if (nodeType == Blockly.ASTNode.types.BLOCK) {\n      this.warn('Cannot mark a block.');\n    } else if (nodeType == Blockly.ASTNode.types.STACK) {\n      this.warn('Cannot mark a stack.');\n    }\n  }\n\n  /**\n   * Pastes the copied block to the marked location.\n   * @param {Blockly.BlockCopyData} copyData The data\n   *     to paste into the workspace.\n   * @param {Blockly.WorkspaceSvg} workspace The workspace to paste the data\n   *     into.\n   * @returns {boolean} True if the paste was sucessful, false otherwise.\n   * @package\n   */\n  paste(copyData, workspace) {\n    let isHandled = false;\n    Blockly.Events.setGroup(true);\n    const block = /** @type {Blockly.BlockSvg} */ (\n      Blockly.clipboard.paste(copyData, workspace)\n    );\n    if (block) {\n      isHandled = this.insertPastedBlock(workspace, block);\n    }\n    Blockly.Events.setGroup(false);\n    return isHandled;\n  }\n\n  /**\n   * Inserts the pasted block at the marked location if a compatible connection\n   * exists. If no connection has been marked, or there is not a compatible\n   * connection then the block is placed on the workspace.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to paste the block\n   *     on.\n   * @param {!Blockly.BlockSvg} block The block to paste.\n   * @returns {boolean} True if the block was pasted to the workspace, false\n   *     otherwise.\n   * @protected\n   */\n  insertPastedBlock(workspace, block) {\n    let isHandled = false;\n    const markedNode = workspace.getMarker(this.MARKER_NAME).getCurNode();\n    if (markedNode) {\n      isHandled = this.tryToConnectMarkerAndCursor(\n        workspace,\n        markedNode,\n        Blockly.ASTNode.createBlockNode(block),\n      );\n    }\n    return isHandled;\n  }\n\n  /**\n   * Removes the change listeners on all registered workspaces.\n   * @package\n   */\n  dispose() {\n    for (const workspace of this.workspaces) {\n      this.removeWorkspace(workspace);\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Overrides methods on Blockly.Gesture in order to allow users\n * to move the cursor to blocks or the workspace using shift click.\n * TODO(google/blockly#4584): We do not have a way to do this currently without\n * monkey patching Blockly.\n * @author aschmiedt@google.com (Abby Schmiedt)\n */\n\nimport * as Blockly from 'blockly/core';\n\nconst oldDoWorkspaceClick = Blockly.Gesture.prototype.doWorkspaceClick_;\n\n/**\n * Execute a workspace click. When in accessibility mode shift clicking will\n * move the cursor.\n * @param {!Event} e A mouse up or touch end event.\n * @this {Blockly.Gesture}\n * @override\n */\nBlockly.Gesture.prototype.doWorkspaceClick_ = function (e) {\n  oldDoWorkspaceClick.call(this, e);\n  const ws = this.creatorWorkspace_;\n  if (e.shiftKey && ws.keyboardAccessibilityMode) {\n    const screenCoord = new Blockly.utils.Coordinate(e.clientX, e.clientY);\n    const wsCoord = Blockly.utils.svgMath.screenToWsCoordinates(\n      ws,\n      screenCoord,\n    );\n    const wsNode = Blockly.ASTNode.createWorkspaceNode(ws, wsCoord);\n    ws.getCursor().setCurNode(wsNode);\n  }\n};\n\nconst oldDoBlockClick = Blockly.Gesture.prototype.doBlockClick_;\n\n/**\n * Execute a block click. When in accessibility mode shift clicking will move\n * the cursor to the block.\n * @this {Blockly.Gesture}\n * @override\n */\nBlockly.Gesture.prototype.doBlockClick_ = function (e) {\n  oldDoBlockClick.call(this, e);\n  if (\n    !this.targetBlock_.isInFlyout &&\n    this.mostRecentEvent_.shiftKey &&\n    this.targetBlock_.workspace.keyboardAccessibilityMode\n  ) {\n    this.creatorWorkspace_\n      .getCursor()\n      .setCurNode(Blockly.ASTNode.createTopNode(this.targetBlock_));\n  }\n};\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Registers all of the keyboard shortcuts that are necessary for\n * navigating blockly using the keyboard.\n * @author aschmiedt@google.com (Abby Schmiedt)\n */\n\nimport './gesture_monkey_patch';\n\nimport * as Blockly from 'blockly/core';\n\nimport * as Constants from './constants';\nimport {Navigation} from './navigation';\n\n/**\n * Class for registering shortcuts for keyboard navigation.\n */\nexport class NavigationController {\n  /** Data copied by the copy or cut keyboard shortcuts. */\n  copyData = null;\n\n  /** The workspace a copy or cut keyboard shortcut happened in. */\n  copyWorkspace = null;\n\n  /**\n   * Constructor used for registering shortcuts.\n   * This will register any default shortcuts for keyboard navigation.\n   * This is intended to be a singleton.\n   * @param {!Navigation=} optNavigation The class that handles keyboard\n   *     navigation shortcuts. (Ex: inserting a block, focusing the flyout).\n   */\n  constructor(optNavigation) {\n    /**\n     * Handles any keyboard navigation shortcuts.\n     * @type {!Navigation}\n     * @public\n     */\n    this.navigation = optNavigation || new Navigation();\n  }\n\n  /**\n   * Registers the default keyboard shortcuts for keyboard navigation.\n   * @public\n   */\n  init() {\n    this.addShortcutHandlers();\n    this.registerDefaults();\n  }\n\n  /**\n   * Adds methods to core Blockly components that allows them to handle keyboard\n   * shortcuts when in keyboard navigation mode.\n   * @protected\n   */\n  addShortcutHandlers() {\n    if (Blockly.FieldColour) {\n      Blockly.FieldColour.prototype.onShortcut = this.fieldColourHandler;\n    }\n\n    if (Blockly.FieldDropdown) {\n      Blockly.FieldDropdown.prototype.onShortcut = this.fieldDropdownHandler;\n    }\n\n    if (Blockly.Toolbox) {\n      Blockly.Toolbox.prototype.onShortcut = this.toolboxHandler;\n    }\n  }\n\n  /**\n   * Removes methods on core Blockly components that allows them to handle\n   * keyboard shortcuts.\n   * @protected\n   */\n  removeShortcutHandlers() {\n    if (Blockly.FieldColour) {\n      Blockly.FieldColour.prototype.onShortcut = null;\n    }\n\n    if (Blockly.FieldDropdown) {\n      Blockly.FieldDropdown.prototype.onShortcut = null;\n    }\n\n    if (Blockly.Toolbox) {\n      Blockly.Toolbox.prototype.onShortcut = null;\n    }\n  }\n\n  /**\n   * Handles the given keyboard shortcut.\n   * This is only triggered when keyboard accessibility mode is enabled.\n   * @param {!Blockly.ShortcutRegistry.KeyboardShortcut} shortcut The shortcut\n   *     to be handled.\n   * @returns {boolean} True if the field handled the shortcut,\n   *     false otherwise.\n   * @this {Blockly.FieldColour}\n   * @protected\n   */\n  fieldColourHandler(shortcut) {\n    if (this.picker_) {\n      switch (shortcut.name) {\n        case Constants.SHORTCUT_NAMES.PREVIOUS:\n          this.moveHighlightBy_(0, -1);\n          return true;\n        case Constants.SHORTCUT_NAMES.NEXT:\n          this.moveHighlightBy_(0, 1);\n          return true;\n        case Constants.SHORTCUT_NAMES.OUT:\n          this.moveHighlightBy_(-1, 0);\n          return true;\n        case Constants.SHORTCUT_NAMES.IN:\n          this.moveHighlightBy_(1, 0);\n          return true;\n        default:\n          return false;\n      }\n    }\n    // If we haven't already handled the shortcut, let the default Field\n    // handler try.\n    return Blockly.Field.prototype.onShortcut.call(this, shortcut);\n  }\n\n  /**\n   * Handles the given keyboard shortcut.\n   * This is only triggered when keyboard accessibility mode is enabled.\n   * @param {!Blockly.ShortcutRegistry.KeyboardShortcut} shortcut The shortcut\n   *     to be handled.\n   * @returns {boolean} True if the field handled the shortcut,\n   *     false otherwise.\n   * @this {Blockly.FieldDropdown}\n   * @protected\n   */\n  fieldDropdownHandler(shortcut) {\n    if (this.menu_) {\n      switch (shortcut.name) {\n        case Constants.SHORTCUT_NAMES.PREVIOUS:\n          this.menu_.highlightPrevious();\n          return true;\n        case Constants.SHORTCUT_NAMES.NEXT:\n          this.menu_.highlightNext();\n          return true;\n        default:\n          return false;\n      }\n    }\n    // If we haven't already handled the shortcut, let the default Field\n    // handler try.\n    return Blockly.Field.prototype.onShortcut.call(this, shortcut);\n  }\n\n  /**\n   * Handles the given keyboard shortcut.\n   * This is only triggered when keyboard accessibility mode is enabled.\n   * @param {!Blockly.ShortcutRegistry.KeyboardShortcut} shortcut The shortcut\n   *     to be handled.\n   * @returns {boolean} True if the toolbox handled the shortcut,\n   *     false otherwise.\n   * @this {Blockly.Toolbox}\n   * @protected\n   */\n  toolboxHandler(shortcut) {\n    if (!this.selectedItem_) {\n      return false;\n    }\n    switch (shortcut.name) {\n      case Constants.SHORTCUT_NAMES.PREVIOUS:\n        return this.selectPrevious_();\n      case Constants.SHORTCUT_NAMES.OUT:\n        return this.selectParent_();\n      case Constants.SHORTCUT_NAMES.NEXT:\n        return this.selectNext_();\n      case Constants.SHORTCUT_NAMES.IN:\n        return this.selectChild_();\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Adds all necessary event listeners and markers to a workspace for keyboard\n   * navigation to work. This must be called for keyboard navigation to work\n   * on a workspace.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to add keyboard\n   *     navigation to.\n   * @public\n   */\n  addWorkspace(workspace) {\n    this.navigation.addWorkspace(workspace);\n  }\n\n  /**\n   * Removes all necessary event listeners and markers to a workspace for\n   * keyboard navigation to work.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to remove keyboard\n   *     navigation from.\n   * @public\n   */\n  removeWorkspace(workspace) {\n    this.navigation.removeWorkspace(workspace);\n  }\n\n  /**\n   * Turns on keyboard navigation.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to turn on keyboard\n   *     navigation for.\n   * @public\n   */\n  enable(workspace) {\n    this.navigation.enableKeyboardAccessibility(workspace);\n  }\n\n  /**\n   * Turns off keyboard navigation.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to turn off keyboard\n   *     navigation on.\n   * @public\n   */\n  disable(workspace) {\n    this.navigation.disableKeyboardAccessibility(workspace);\n  }\n\n  /**\n   * Gives the cursor to the field to handle if the cursor is on a field.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to check.\n   * @param {!Blockly.ShortcutRegistry.KeyboardShortcut} shortcut The shortcut\n   *     to give to the field.\n   * @returns {boolean} True if the shortcut was handled by the field, false\n   *     otherwise.\n   * @protected\n   */\n  fieldShortcutHandler(workspace, shortcut) {\n    const cursor = workspace.getCursor();\n    if (!cursor || !cursor.getCurNode()) {\n      return false;\n    }\n    const curNode = cursor.getCurNode();\n    if (curNode.getType() === Blockly.ASTNode.types.FIELD) {\n      return /** @type {!Blockly.Field} */ (curNode.getLocation()).onShortcut(\n        shortcut,\n      );\n    }\n    return false;\n  }\n\n  /**\n   * Keyboard shortcut to go to the previous location when in keyboard\n   * navigation mode.\n   * @protected\n   */\n  registerPrevious() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const previousShortcut = {\n      name: Constants.SHORTCUT_NAMES.PREVIOUS,\n      preconditionFn: (workspace) => {\n        return workspace.keyboardAccessibilityMode;\n      },\n      callback: (workspace, e, shortcut) => {\n        const flyout = workspace.getFlyout();\n        const toolbox = workspace.getToolbox();\n        let isHandled = false;\n        switch (this.navigation.getState(workspace)) {\n          case Constants.STATE.WORKSPACE:\n            isHandled = this.fieldShortcutHandler(workspace, shortcut);\n            if (!isHandled) {\n              workspace.getCursor().prev();\n              isHandled = true;\n            }\n            return isHandled;\n          case Constants.STATE.FLYOUT:\n            isHandled = this.fieldShortcutHandler(workspace, shortcut);\n            if (!isHandled) {\n              flyout.getWorkspace().getCursor().prev();\n              isHandled = true;\n            }\n            return isHandled;\n          case Constants.STATE.TOOLBOX:\n            return toolbox && typeof toolbox.onShortcut == 'function'\n              ? toolbox.onShortcut(shortcut)\n              : false;\n          default:\n            return false;\n        }\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(previousShortcut);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      Blockly.utils.KeyCodes.W,\n      previousShortcut.name,\n    );\n  }\n\n  /**\n   * Keyboard shortcut to turn keyboard navigation on or off.\n   * @protected\n   */\n  registerToggleKeyboardNav() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const toggleKeyboardNavShortcut = {\n      name: Constants.SHORTCUT_NAMES.TOGGLE_KEYBOARD_NAV,\n      callback: (workspace) => {\n        if (workspace.keyboardAccessibilityMode) {\n          this.navigation.disableKeyboardAccessibility(workspace);\n        } else {\n          this.navigation.enableKeyboardAccessibility(workspace);\n        }\n        return true;\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(toggleKeyboardNavShortcut);\n    const ctrlShiftK = Blockly.ShortcutRegistry.registry.createSerializedKey(\n      Blockly.utils.KeyCodes.K,\n      [Blockly.utils.KeyCodes.CTRL, Blockly.utils.KeyCodes.SHIFT],\n    );\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      ctrlShiftK,\n      toggleKeyboardNavShortcut.name,\n    );\n  }\n\n  /**\n   * Keyboard shortcut to go to the out location when in keyboard navigation\n   * mode.\n   * @protected\n   */\n  registerOut() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const outShortcut = {\n      name: Constants.SHORTCUT_NAMES.OUT,\n      preconditionFn: (workspace) => {\n        return workspace.keyboardAccessibilityMode;\n      },\n      callback: (workspace, e, shortcut) => {\n        const toolbox = workspace.getToolbox();\n        let isHandled = false;\n        switch (this.navigation.getState(workspace)) {\n          case Constants.STATE.WORKSPACE:\n            isHandled = this.fieldShortcutHandler(workspace, shortcut);\n            if (!isHandled) {\n              workspace.getCursor().out();\n              isHandled = true;\n            }\n            return isHandled;\n          case Constants.STATE.FLYOUT:\n            this.navigation.focusToolbox(workspace);\n            return true;\n          case Constants.STATE.TOOLBOX:\n            return toolbox && typeof toolbox.onShortcut == 'function'\n              ? toolbox.onShortcut(shortcut)\n              : false;\n          default:\n            return false;\n        }\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(outShortcut);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      Blockly.utils.KeyCodes.A,\n      outShortcut.name,\n    );\n  }\n\n  /**\n   * Keyboard shortcut to go to the next location when in keyboard navigation\n   * mode.\n   * @protected\n   */\n  registerNext() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const nextShortcut = {\n      name: Constants.SHORTCUT_NAMES.NEXT,\n      preconditionFn: (workspace) => {\n        return workspace.keyboardAccessibilityMode;\n      },\n      callback: (workspace, e, shortcut) => {\n        const toolbox = workspace.getToolbox();\n        const flyout = workspace.getFlyout();\n        let isHandled = false;\n        switch (this.navigation.getState(workspace)) {\n          case Constants.STATE.WORKSPACE:\n            isHandled = this.fieldShortcutHandler(workspace, shortcut);\n            if (!isHandled) {\n              workspace.getCursor().next();\n              isHandled = true;\n            }\n            return isHandled;\n          case Constants.STATE.FLYOUT:\n            isHandled = this.fieldShortcutHandler(workspace, shortcut);\n            if (!isHandled) {\n              flyout.getWorkspace().getCursor().next();\n              isHandled = true;\n            }\n            return isHandled;\n          case Constants.STATE.TOOLBOX:\n            return toolbox && typeof toolbox.onShortcut == 'function'\n              ? toolbox.onShortcut(shortcut)\n              : false;\n          default:\n            return false;\n        }\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(nextShortcut);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      Blockly.utils.KeyCodes.S,\n      nextShortcut.name,\n    );\n  }\n\n  /**\n   * Keyboard shortcut to go to the in location when in keyboard navigation\n   * mode.\n   * @protected\n   */\n  registerIn() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const inShortcut = {\n      name: Constants.SHORTCUT_NAMES.IN,\n      preconditionFn: (workspace) => {\n        return workspace.keyboardAccessibilityMode;\n      },\n      callback: (workspace, e, shortcut) => {\n        const toolbox = workspace.getToolbox();\n        let isHandled = false;\n        switch (this.navigation.getState(workspace)) {\n          case Constants.STATE.WORKSPACE:\n            isHandled = this.fieldShortcutHandler(workspace, shortcut);\n            if (!isHandled) {\n              workspace.getCursor().in();\n              isHandled = true;\n            }\n            return isHandled;\n          case Constants.STATE.TOOLBOX:\n            isHandled =\n              toolbox && typeof toolbox.onShortcut == 'function'\n                ? toolbox.onShortcut(shortcut)\n                : false;\n            if (!isHandled) {\n              this.navigation.focusFlyout(workspace);\n            }\n            return true;\n          default:\n            return false;\n        }\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(inShortcut);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      Blockly.utils.KeyCodes.D,\n      inShortcut.name,\n    );\n  }\n\n  /**\n   * Keyboard shortcut to connect a block to a marked location when in keyboard\n   * navigation mode.\n   * @protected\n   */\n  registerInsert() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const insertShortcut = {\n      name: Constants.SHORTCUT_NAMES.INSERT,\n      preconditionFn: (workspace) => {\n        return (\n          workspace.keyboardAccessibilityMode && !workspace.options.readOnly\n        );\n      },\n      callback: (workspace) => {\n        switch (this.navigation.getState(workspace)) {\n          case Constants.STATE.WORKSPACE:\n            return this.navigation.connectMarkerAndCursor(workspace);\n          default:\n            return false;\n        }\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(insertShortcut);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      Blockly.utils.KeyCodes.I,\n      insertShortcut.name,\n    );\n  }\n\n  /**\n   * Keyboard shortcut to mark a location when in keyboard navigation mode.\n   * @protected\n   */\n  registerMark() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const markShortcut = {\n      name: Constants.SHORTCUT_NAMES.MARK,\n      preconditionFn: (workspace) => {\n        return (\n          workspace.keyboardAccessibilityMode && !workspace.options.readOnly\n        );\n      },\n      callback: (workspace) => {\n        switch (this.navigation.getState(workspace)) {\n          case Constants.STATE.WORKSPACE:\n            this.navigation.handleEnterForWS(workspace);\n            return true;\n          case Constants.STATE.FLYOUT:\n            this.navigation.insertFromFlyout(workspace);\n            return true;\n          default:\n            return false;\n        }\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(markShortcut);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      Blockly.utils.KeyCodes.ENTER,\n      markShortcut.name,\n    );\n  }\n\n  /**\n   * Keyboard shortcut to disconnect two blocks when in keyboard navigation\n   * mode.\n   * @protected\n   */\n  registerDisconnect() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const disconnectShortcut = {\n      name: Constants.SHORTCUT_NAMES.DISCONNECT,\n      preconditionFn: (workspace) => {\n        return (\n          workspace.keyboardAccessibilityMode && !workspace.options.readOnly\n        );\n      },\n      callback: (workspace) => {\n        switch (this.navigation.getState(workspace)) {\n          case Constants.STATE.WORKSPACE:\n            this.navigation.disconnectBlocks(workspace);\n            return true;\n          default:\n            return false;\n        }\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(disconnectShortcut);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      Blockly.utils.KeyCodes.X,\n      disconnectShortcut.name,\n    );\n  }\n\n  /**\n   * Keyboard shortcut to focus on the toolbox when in keyboard navigation\n   * mode.\n   * @protected\n   */\n  registerToolboxFocus() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const focusToolboxShortcut = {\n      name: Constants.SHORTCUT_NAMES.TOOLBOX,\n      preconditionFn: (workspace) => {\n        return (\n          workspace.keyboardAccessibilityMode && !workspace.options.readOnly\n        );\n      },\n      callback: (workspace) => {\n        switch (this.navigation.getState(workspace)) {\n          case Constants.STATE.WORKSPACE:\n            if (!workspace.getToolbox()) {\n              this.navigation.focusFlyout(workspace);\n            } else {\n              this.navigation.focusToolbox(workspace);\n            }\n            return true;\n          default:\n            return false;\n        }\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(focusToolboxShortcut);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      Blockly.utils.KeyCodes.T,\n      focusToolboxShortcut.name,\n    );\n  }\n\n  /**\n   * Keyboard shortcut to exit the current location and focus on the workspace\n   * when in keyboard navigation mode.\n   * @protected\n   */\n  registerExit() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const exitShortcut = {\n      name: Constants.SHORTCUT_NAMES.EXIT,\n      preconditionFn: (workspace) => {\n        return workspace.keyboardAccessibilityMode;\n      },\n      callback: (workspace) => {\n        switch (this.navigation.getState(workspace)) {\n          case Constants.STATE.FLYOUT:\n            this.navigation.focusWorkspace(workspace);\n            return true;\n          case Constants.STATE.TOOLBOX:\n            this.navigation.focusWorkspace(workspace);\n            return true;\n          default:\n            return false;\n        }\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(exitShortcut, true);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      Blockly.utils.KeyCodes.ESC,\n      exitShortcut.name,\n      true,\n    );\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      Blockly.utils.KeyCodes.E,\n      exitShortcut.name,\n      true,\n    );\n  }\n\n  /**\n   * Keyboard shortcut to move the cursor on the workspace to the left when in\n   * keyboard navigation mode.\n   * @protected\n   */\n  registerWorkspaceMoveLeft() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const wsMoveLeftShortcut = {\n      name: Constants.SHORTCUT_NAMES.MOVE_WS_CURSOR_LEFT,\n      preconditionFn: (workspace) => {\n        return (\n          workspace.keyboardAccessibilityMode && !workspace.options.readOnly\n        );\n      },\n      callback: (workspace) => {\n        return this.navigation.moveWSCursor(workspace, -1, 0);\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(wsMoveLeftShortcut);\n    const shiftA = Blockly.ShortcutRegistry.registry.createSerializedKey(\n      Blockly.utils.KeyCodes.A,\n      [Blockly.utils.KeyCodes.SHIFT],\n    );\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      shiftA,\n      wsMoveLeftShortcut.name,\n    );\n  }\n\n  /**\n   * Keyboard shortcut to move the cursor on the workspace to the right when in\n   * keyboard navigation mode.\n   * @protected\n   */\n  registerWorkspaceMoveRight() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const wsMoveRightShortcut = {\n      name: Constants.SHORTCUT_NAMES.MOVE_WS_CURSOR_RIGHT,\n      preconditionFn: (workspace) => {\n        return (\n          workspace.keyboardAccessibilityMode && !workspace.options.readOnly\n        );\n      },\n      callback: (workspace) => {\n        return this.navigation.moveWSCursor(workspace, 1, 0);\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(wsMoveRightShortcut);\n    const shiftD = Blockly.ShortcutRegistry.registry.createSerializedKey(\n      Blockly.utils.KeyCodes.D,\n      [Blockly.utils.KeyCodes.SHIFT],\n    );\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      shiftD,\n      wsMoveRightShortcut.name,\n    );\n  }\n\n  /**\n   * Keyboard shortcut to move the cursor on the workspace up when in keyboard\n   * navigation mode.\n   * @protected\n   */\n  registerWorkspaceMoveUp() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const wsMoveUpShortcut = {\n      name: Constants.SHORTCUT_NAMES.MOVE_WS_CURSOR_UP,\n      preconditionFn: (workspace) => {\n        return (\n          workspace.keyboardAccessibilityMode && !workspace.options.readOnly\n        );\n      },\n      callback: (workspace) => {\n        return this.navigation.moveWSCursor(workspace, 0, -1);\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(wsMoveUpShortcut);\n    const shiftW = Blockly.ShortcutRegistry.registry.createSerializedKey(\n      Blockly.utils.KeyCodes.W,\n      [Blockly.utils.KeyCodes.SHIFT],\n    );\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      shiftW,\n      wsMoveUpShortcut.name,\n    );\n  }\n\n  /**\n   * Keyboard shortcut to move the cursor on the workspace down when in\n   * keyboard navigation mode.\n   * @protected\n   */\n  registerWorkspaceMoveDown() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const wsMoveDownShortcut = {\n      name: Constants.SHORTCUT_NAMES.MOVE_WS_CURSOR_DOWN,\n      preconditionFn: (workspace) => {\n        return (\n          workspace.keyboardAccessibilityMode && !workspace.options.readOnly\n        );\n      },\n      callback: (workspace) => {\n        return this.navigation.moveWSCursor(workspace, 0, 1);\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(wsMoveDownShortcut);\n    const shiftW = Blockly.ShortcutRegistry.registry.createSerializedKey(\n      Blockly.utils.KeyCodes.S,\n      [Blockly.utils.KeyCodes.SHIFT],\n    );\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      shiftW,\n      wsMoveDownShortcut.name,\n    );\n  }\n\n  /**\n   * Keyboard shortcut to copy the block the cursor is currently on.\n   * @protected\n   */\n  registerCopy() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const copyShortcut = {\n      name: Constants.SHORTCUT_NAMES.COPY,\n      preconditionFn: (workspace) => {\n        if (\n          workspace.keyboardAccessibilityMode &&\n          !workspace.options.readOnly\n        ) {\n          const curNode = workspace.getCursor().getCurNode();\n          if (curNode && curNode.getSourceBlock()) {\n            const sourceBlock = curNode.getSourceBlock();\n            return (\n              !Blockly.Gesture.inProgress() &&\n              sourceBlock &&\n              sourceBlock.isDeletable() &&\n              sourceBlock.isMovable()\n            );\n          }\n        }\n        return false;\n      },\n      callback: (workspace) => {\n        const sourceBlock = /** @type {Blockly.BlockSvg} */ (\n          workspace.getCursor().getCurNode().getSourceBlock()\n        );\n        workspace.hideChaff();\n        this.copyData = sourceBlock.toCopyData();\n        this.copyWorkspace = sourceBlock.workspace;\n        return !!this.copyData;\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(copyShortcut);\n\n    const ctrlC = Blockly.ShortcutRegistry.registry.createSerializedKey(\n      Blockly.utils.KeyCodes.C,\n      [Blockly.utils.KeyCodes.CTRL],\n    );\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      ctrlC,\n      copyShortcut.name,\n      true,\n    );\n\n    const altC = Blockly.ShortcutRegistry.registry.createSerializedKey(\n      Blockly.utils.KeyCodes.C,\n      [Blockly.utils.KeyCodes.ALT],\n    );\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      altC,\n      copyShortcut.name,\n      true,\n    );\n\n    const metaC = Blockly.ShortcutRegistry.registry.createSerializedKey(\n      Blockly.utils.KeyCodes.C,\n      [Blockly.utils.KeyCodes.META],\n    );\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      metaC,\n      copyShortcut.name,\n      true,\n    );\n  }\n\n  /**\n   * Register shortcut to paste the copied block to the marked location.\n   * @protected\n   */\n  registerPaste() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const pasteShortcut = {\n      name: Constants.SHORTCUT_NAMES.PASTE,\n      preconditionFn: (workspace) => {\n        return (\n          workspace.keyboardAccessibilityMode &&\n          !workspace.options.readOnly &&\n          !Blockly.Gesture.inProgress()\n        );\n      },\n      callback: () => {\n        if (!this.copyData || !this.copyWorkspace) return false;\n        return this.navigation.paste(this.copyData, this.copyWorkspace);\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(pasteShortcut);\n\n    const ctrlV = Blockly.ShortcutRegistry.registry.createSerializedKey(\n      Blockly.utils.KeyCodes.V,\n      [Blockly.utils.KeyCodes.CTRL],\n    );\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      ctrlV,\n      pasteShortcut.name,\n      true,\n    );\n\n    const altV = Blockly.ShortcutRegistry.registry.createSerializedKey(\n      Blockly.utils.KeyCodes.V,\n      [Blockly.utils.KeyCodes.ALT],\n    );\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      altV,\n      pasteShortcut.name,\n      true,\n    );\n\n    const metaV = Blockly.ShortcutRegistry.registry.createSerializedKey(\n      Blockly.utils.KeyCodes.V,\n      [Blockly.utils.KeyCodes.META],\n    );\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      metaV,\n      pasteShortcut.name,\n      true,\n    );\n  }\n\n  /**\n   * Keyboard shortcut to copy and delete the block the cursor is on using\n   * ctrl+x, cmd+x, or alt+x.\n   * @protected\n   */\n  registerCut() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const cutShortcut = {\n      name: Constants.SHORTCUT_NAMES.CUT,\n      preconditionFn: (workspace) => {\n        if (\n          workspace.keyboardAccessibilityMode &&\n          !workspace.options.readOnly\n        ) {\n          const curNode = workspace.getCursor().getCurNode();\n          if (curNode && curNode.getSourceBlock()) {\n            const sourceBlock = curNode.getSourceBlock();\n            return (\n              !Blockly.Gesture.inProgress() &&\n              sourceBlock &&\n              sourceBlock.isDeletable() &&\n              sourceBlock.isMovable() &&\n              !sourceBlock.workspace.isFlyout\n            );\n          }\n        }\n        return false;\n      },\n      callback: (workspace) => {\n        const sourceBlock = /** @type {Blockly.BlockSvg} */ (\n          workspace.getCursor().getCurNode().getSourceBlock()\n        );\n        this.copyData = sourceBlock.toCopyData();\n        this.copyWorkspace = sourceBlock.workspace;\n        this.navigation.moveCursorOnBlockDelete(workspace, sourceBlock);\n        sourceBlock.checkAndDelete();\n        return true;\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(cutShortcut);\n\n    const ctrlX = Blockly.ShortcutRegistry.registry.createSerializedKey(\n      Blockly.utils.KeyCodes.X,\n      [Blockly.utils.KeyCodes.CTRL],\n    );\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      ctrlX,\n      cutShortcut.name,\n      true,\n    );\n\n    const altX = Blockly.ShortcutRegistry.registry.createSerializedKey(\n      Blockly.utils.KeyCodes.X,\n      [Blockly.utils.KeyCodes.ALT],\n    );\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      altX,\n      cutShortcut.name,\n      true,\n    );\n\n    const metaX = Blockly.ShortcutRegistry.registry.createSerializedKey(\n      Blockly.utils.KeyCodes.X,\n      [Blockly.utils.KeyCodes.META],\n    );\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      metaX,\n      cutShortcut.name,\n      true,\n    );\n  }\n\n  /**\n   * Registers shortcut to delete the block the cursor is on using delete or\n   * backspace.\n   * @protected\n   */\n  registerDelete() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const deleteShortcut = {\n      name: Constants.SHORTCUT_NAMES.DELETE,\n      preconditionFn: function (workspace) {\n        if (\n          workspace.keyboardAccessibilityMode &&\n          !workspace.options.readOnly\n        ) {\n          const curNode = workspace.getCursor().getCurNode();\n          if (curNode && curNode.getSourceBlock()) {\n            const sourceBlock = curNode.getSourceBlock();\n            return sourceBlock && sourceBlock.isDeletable();\n          }\n        }\n        return false;\n      },\n      callback: (workspace, e) => {\n        const sourceBlock = workspace.getCursor().getCurNode().getSourceBlock();\n        // Delete or backspace.\n        // Stop the browser from going back to the previous page.\n        // Do this first to prevent an error in the delete code from resulting\n        // in data loss.\n        e.preventDefault();\n        // Don't delete while dragging.  Jeez.\n        if (Blockly.Gesture.inProgress()) {\n          return false;\n        }\n        this.navigation.moveCursorOnBlockDelete(workspace, sourceBlock);\n        sourceBlock.checkAndDelete();\n        return true;\n      },\n    };\n    Blockly.ShortcutRegistry.registry.register(deleteShortcut);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      Blockly.utils.KeyCodes.DELETE,\n      deleteShortcut.name,\n      true,\n    );\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      Blockly.utils.KeyCodes.BACKSPACE,\n      deleteShortcut.name,\n      true,\n    );\n  }\n\n  /**\n   * Registers all default keyboard shortcut items for keyboard navigation. This\n   * should be called once per instance of KeyboardShortcutRegistry.\n   * @protected\n   */\n  registerDefaults() {\n    this.registerPrevious();\n    this.registerNext();\n    this.registerIn();\n    this.registerOut();\n\n    this.registerDisconnect();\n    this.registerExit();\n    this.registerInsert();\n    this.registerMark();\n    this.registerToolboxFocus();\n    this.registerToggleKeyboardNav();\n\n    this.registerWorkspaceMoveDown();\n    this.registerWorkspaceMoveLeft();\n    this.registerWorkspaceMoveUp();\n    this.registerWorkspaceMoveRight();\n\n    this.registerCopy();\n    this.registerPaste();\n    this.registerCut();\n    this.registerDelete();\n  }\n\n  /**\n   * Removes all the keyboard navigation shortcuts.\n   * @public\n   */\n  dispose() {\n    const shortcutNames = Object.values(Constants.SHORTCUT_NAMES);\n    for (const name of shortcutNames) {\n      Blockly.ShortcutRegistry.registry.unregister(name);\n    }\n    this.removeShortcutHandlers();\n    this.navigation.dispose();\n  }\n}\n"],"names":["root","factory","exports","module","require","define","amd","a","i","this","__WEBPACK_EXTERNAL_MODULE__573__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","STATE","WORKSPACE","FLYOUT","TOOLBOX","SHORTCUT_NAMES","PREVIOUS","NEXT","IN","OUT","INSERT","MARK","DISCONNECT","EXIT","TOGGLE_KEYBOARD_NAV","COPY","CUT","PASTE","DELETE","MOVE_WS_CURSOR_UP","MOVE_WS_CURSOR_DOWN","MOVE_WS_CURSOR_LEFT","MOVE_WS_CURSOR_RIGHT","LOGGING_MSG_TYPE","ERROR","WARN","LOG","FlyoutCursor","constructor","super","next","curNode","getCurNode","newNode","setCurNode","in","prev","out","registrationType","registrationName","pluginInfo","LineCursor","getNextNode_","validLineNode","getType","getLocation","targetBlock","validInLineNode","getPreviousNode_","node","isValid","location","type","outputConnection","Navigation","workspaceStates","loggingCallback","WS_MOVE_DISTANCE","MARKER_NAME","DEFAULT_WS_COORDINATE","WS_COORDINATE_ON_DELETE","wsChangeWrapper","workspaceChangeListener","bind","flyoutChangeWrapper","flyoutChangeListener","workspaces","addWorkspace","workspace","push","flyout","getFlyout","getMarkerManager","registerMarker","addChangeListener","addFlyout","removeWorkspace","workspaceIdx","indexOf","getCursor","disableKeyboardAccessibility","splice","unregisterMarker","removeChangeListener","removeFlyout","setState","state","id","getState","getMarker","flyoutWorkspace","getWorkspace","FlyoutCursorClass","setCursor","e","workspaceId","keyboardAccessibilityMode","handleBlockDeleteByDrag","element","handleBlockMutation","handleWorkspaceClick","handleToolboxCategoryClick","handleBlockCreate","mainWorkspace","targetWorkspace","autoClose","targetType","block","getBlockById","blockId","handleBlockClickInFlyout","newElementId","resetFlyout","getToolbox","mutatedBlockId","cursor","getSourceBlock","workspaceState","newItem","focusToolbox","deletedBlockId","ids","sourceBlock","isShadow","getParent","getFlyoutCursor","moveCursorOnBlockDelete","deletedBlock","topConnection","previousConnection","targetConnection","getRelativeToSurfaceXY","getChildren","toolbox","markAtCursor","getSelectedItem","toolboxItems","getToolboxItems","toolboxItem","isSelectable","selectItemByPosition","focusFlyout","topBlocks","getTopBlocks","length","astNode","focusWorkspace","hideChaff","reset","setCursorOnWorkspaceFocus","wsCoordinates","x","scale","y","wsNode","insertFromFlyout","newBlock","createNewBlock","markerNode","tryToConnectMarkerAndCursor","warn","removeMark","isVisible","curBlock","isEnabled","createBlock","render","setConnectionTracking","shouldHide","hide","connectMarkerAndCursor","cursorNode","logConnectionWarning","markerType","cursorType","cursorLoc","markerLoc","isConnection","cursorConnection","markerConnection","connect","cursorBlock","insertBlock","moveBlockToWorkspace","unplug","moveTo","getWsCoordinate","disconnectChild","movingConnection","destConnection","movingBlock","destBlock","inferiorConnection","getRootBlock","getDescendants","getInferiorConnection","disconnect","movingInferior","destSuperior","getSuperiorConnection","movingSuperior","destInferior","moveAndConnect","checker","getConnectionChecker","reason","canConnectWithReason","getErrorMessage","connection","isSuperior","canConnect","rootBlock","originalOffsetToTarget","originalOffsetInBlock","getOffsetInBlock","clone","positionNearConnection","nextConnection","inputList","inputConnection","disconnectBlocks","log","curConnection","isConnected","superiorConnection","bumpAwayFrom","bringToFront","connectionNode","marker","enableKeyboardAccessibility","msg","console","error","moveWSCursor","xDirection","yDirection","wsCoord","newX","newY","handleEnterForWS","nodeType","showEditor","paste","copyData","isHandled","insertPastedBlock","markedNode","dispose","oldDoWorkspaceClick","ws","creatorWorkspace_","shiftKey","screenCoord","clientX","clientY","oldDoBlockClick","targetBlock_","isInFlyout","mostRecentEvent_","NavigationController","copyWorkspace","optNavigation","navigation","init","addShortcutHandlers","registerDefaults","fieldColourHandler","fieldDropdownHandler","toolboxHandler","removeShortcutHandlers","shortcut","picker_","name","moveHighlightBy_","menu_","highlightPrevious","highlightNext","selectedItem_","selectPrevious_","selectParent_","selectNext_","selectChild_","enable","disable","fieldShortcutHandler","onShortcut","registerPrevious","previousShortcut","preconditionFn","callback","registerToggleKeyboardNav","toggleKeyboardNavShortcut","ctrlShiftK","registerOut","outShortcut","registerNext","nextShortcut","registerIn","inShortcut","registerInsert","insertShortcut","options","readOnly","registerMark","markShortcut","registerDisconnect","disconnectShortcut","registerToolboxFocus","focusToolboxShortcut","registerExit","exitShortcut","registerWorkspaceMoveLeft","wsMoveLeftShortcut","shiftA","registerWorkspaceMoveRight","wsMoveRightShortcut","shiftD","registerWorkspaceMoveUp","wsMoveUpShortcut","shiftW","registerWorkspaceMoveDown","wsMoveDownShortcut","registerCopy","copyShortcut","isDeletable","isMovable","toCopyData","ctrlC","altC","metaC","registerPaste","pasteShortcut","ctrlV","altV","metaV","registerCut","cutShortcut","isFlyout","checkAndDelete","ctrlX","altX","metaX","registerDelete","deleteShortcut","preventDefault","shortcutNames","values"],"sourceRoot":""}